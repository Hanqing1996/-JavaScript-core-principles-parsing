JavaScript 中不只有语句和表达式是可以执行的，还有一些特殊的可执行结构。

#### 参数表

所谓“将函数实例化”就是将函数从源代码文本变成一个可以执行的、运行期的闭包的过程。



在这个过程中，参数表作为可执行结构，它的执行结果就是将传入的参数值变成与形式参数规格一致的实际参数，最终将这些参数中所有的值与它们“在形式参数表中的名字”绑定起来，作为函数闭包中可以访问的名字。



简单来说，**把参数放在 arguments 列表中，然后让 arguments 中的值与参数表中的名字对应起来。而这就是对“参数表（argArray）”这个可执行结构的全部操作。**



**but!!!**

* JavaScript 中有个东西没有参数表，那就是箭头函数，那么上面的逻辑是如何实现的呢？

> 箭头函数也是采用与上述过程完全一致的处理逻辑，只是在最后没有向闭包绑定 arguments 



#### 缺省参数

```javascript
function foo(x = 100) {
  console.log(x)
}
foo() // 100
```

这意味着在语法分析期，JavaScript 就得帮助该参数登记下“100”这个值。然后在实际处理这个参数时，至少需要一个赋值表达式的操作，用来将这个值与它的名字绑定起来。所以，foo() 函数调用时，总有一段执行逻辑来访问形式参数表以及执行这个赋值表达式。



作为`rhs`的表达式可以不只是一个字面量值

```javascript
var x = 0;
function foo(i = x++) {
  console.log(i);
}
foo(); // 1st
foo(); // 2nd
```

由于表达式可以引用上下文中的其它变量，因此上面的所谓“登记”，就不能只是记下一个字面量值那么简单，必须登记一个表达式，并且在运行期执行它。



每次调用 foo() 的时候，“x++”就都会得到执行了。

#### 模板字面量

同上理

```javascript
function foo({x, y}) {console.log(x);console.log(y)}

foo({x:'libai',y:20}) // libai 20
```

所有的赋值模板，都是在语法解析期就被分析出来，并在 JavaScript 内部作为一个可执行结构存放着。然后在运行期，会用它们来完成一个“从右操作数按模板取值，并赋值给左操作数”的过程。
