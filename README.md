> 周爱民老师的《 JavaScript核心原理解析》总结


## 声明
#### 标识符
```
let x
```
x 就是一个标识符

#### 变量声明在引擎的处理
> 变量声明在引擎的处理上被分成两个部分：一部分是静态的、基于标识符的词法分析和管理，我们称之为<strong>声明标识符</strong>，它总是在相应上下文的环境构建时作为名字创建的，我们称之为<strong>创建标识符</strong>，注意；另一部分是表达式执行过程，是对上述名字的赋值，这个过程也称为绑定。
1. JavaScript 将可以通过“静态”语法分析（Parser 的工作）发现那些声明的标识符；
2. 标识符对应的变量 / 常量“一定”会在代码执行前就已经被创建在作用域中。


---
## 赋值
> 如果是在一门其它的（例如编译型的）语言中，“为变量 x 绑定一个初值”就可能实现为“在创建环境时将变量 x 指向一个特定的初始值”。这通常是静态语言的处理方法，然而，如前面说过的，JavaScript 是门动态的语言，所以它的“绑定初值”的行为是通过动态的执行过程来实现的，也就是赋值操作。


#### var 的初始化
···
var y = "outer";
function f() {
  console.log(y); // undefined
  console.log(x); // throw a Exception
  let x = 100;
  var y = 100;
}
···
> 正是由于var y所声明的那个标识符在函数 f() 创建（它自己的闭包）时就已经存在，所以才阻止了console.log(y)访问全局环境中的y。类似的，let x所声明的那个x其实也已经存在 f() 函数的上下文环境中。访问它之所以会抛出异常（Exception），不是因为它不存在，而是因为<strong>这个标识符被拒绝访问了</<strong>>。

> 在 ECMAScript 6 之后出现的let/const变量在“声明（和创建）一个标识符”这件事上，与var并没有什么不同，只是 JavaScript 拒绝访问还没有绑定值的let/const标识符而已。

> 回到 ECMAScript 6 之前：JavaScript 是允许访问还没有绑定值的var所声明的标识符的。这种标识符后来统一约定称为“变量声明（varDelcs）”，而“let/const”则称为“词法声明（lexicalDecls）”。>

> JavaScript 环境在创建一个“变量名”后，会为它初始化绑定一个 undefined 值，而”词法名字（lexicalNames）”在创建之后就没有这项待遇，所以它们在缺省情况下就是“还没有绑定值”的标识符。
